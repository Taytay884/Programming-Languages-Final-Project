def generate_values():
    print('Generating values...')
    yield 1
    yield 2
    yield 3

def square(x):
    print(f'Squaring {x}')
    return x * x

print('Eager evaluation:')
values = list(generate_values())
squared_values = [square(x) for x in values]
print(squared_values)

print('\nLazy evaluation:')
squared_values = [square(x) for x in generate_values()]
print(squared_values)

'''

When the program runs in "eager evaluation" mode:

It first calls list(generate_values()) to exhaust the generator and store all yielded values [1, 2, 3].
Then, it applies the square() function to each of these values to get [1, 4, 9].
In this eager evaluation mode, the generator function is *** Fully Executed ***,
and all its values are generated and stored in memory *** BEFORE *** further processing.

However, when the program runs in "lazy evaluation" mode:

It directly uses a list comprehension "[square(x) for x in generate_values()]".
The list comprehension iterates over generate_values(), but at *** EACH *** iteration it only consumes *** ONE *** value from the generator 
and squares it immediately without storing the whole list of values first.

Therefore, each value is generated by generate_values() only when it's needed).

(This leads to a more memory-efficient process because the generator doesn't need to store all its values in memory at once.
it produces them on-demand.)

'''